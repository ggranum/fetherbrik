/*
 * This software is licensed under the MIT License.
 *
 * Copyright (c) 2019 Geoff M. Granum
 */
package com.geoffgranum.uttu.core.persistence.id;

import com.geoffgranum.uttu.core.log.Log;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.primitives.Ints;
import com.google.common.primitives.Longs;
import com.google.inject.Singleton;
import org.apache.commons.codec.binary.Hex;

import javax.annotation.Nonnull;
import javax.annotation.concurrent.Immutable;
import javax.annotation.concurrent.ThreadSafe;
import java.lang.management.ManagementFactory;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Enumeration;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Id generally of the form described here: http://www.mongodb.org/display/DOCS/Object+IDs
 * <p>
 * However, uses full 8 bytes of a long for time field instead of the 4 of an integer.
 * <p>
 * [00][01][02][03][04][05][06][07]   [08][09][10]   [11][12]   [13][14][15]
 * | time(8)                         | machine(3)   | pid(2)  |  inc(3)      |
 * 8 Bytes for time (current time in millis)
 * 3 Bytes for machine ID
 * 2 Bytes for process ID
 * 3 Byte auto increment field.
 */
@Singleton
@ThreadSafe
@Immutable
public final class DefaultIdGenerator implements IdGenerator {

  private static final int THREE_BYTE_INT_MAX_VALUE = 1677216;
  private static final byte[] processIdHash = processIdHash();
  private static final byte[] machineIdHash = machineIdHash();
  private final AtomicInteger autoInc = new AtomicInteger((int) (Math.random() * THREE_BYTE_INT_MAX_VALUE));

  /**
   * Only called if, for some odd reason, the call to NetworkInterface.getByInetAddress fails.
   *
   * @return A mac address, if found.
   */
  @VisibleForTesting
  static byte[] searchNetworksForMacAddress() throws SocketException {
    Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
    byte[] mac = {};
    while (networkInterfaces.hasMoreElements()) {
      NetworkInterface net = networkInterfaces.nextElement();
      mac = net.getHardwareAddress();
      if (mac != null) {
        Log.trace(DefaultIdGenerator.class,
            "Using MAC address for network interface %s to provide hardware part of future UUIDs generated by this class",
            net.getDisplayName());
        break;
      }
    }
    return mac;
  }

  private static void checkForOverflow(AtomicInteger autoInc) {
    if (autoInc.get() >= THREE_BYTE_INT_MAX_VALUE) {
      Log.trace(DefaultIdGenerator.class, "AutoInc field rolled over to 0.");
      autoInc.set(0);
    }
  }

  private static byte[] processIdHash() {
    try {
      byte[] name = ManagementFactory.getRuntimeMXBean().getName().getBytes(StandardCharsets.UTF_8);
      return MessageDigest.getInstance("MD5").digest(name);
    } catch (NoSuchAlgorithmException e) {
      Log.error(DefaultIdGenerator.class, e, "Could not calculate a process ID hash.");
      throw new RuntimeException(e);
    }
  }

  private static byte[] machineIdHash() {
    try {
      InetAddress ip = InetAddress.getLocalHost();
      NetworkInterface network = NetworkInterface.getByInetAddress(ip);
      byte[] mac = null;
      if (network != null) {
        mac = network.getHardwareAddress();
      }
      if (mac == null) {
        Log.warn(DefaultIdGenerator.class,
            "Could not retrieve mac address from localHost ip address. This is unusual. Using first MAC found in network interfaces.");
        mac = searchNetworksForMacAddress();
      }
      return MessageDigest.getInstance("MD5").digest(mac);
    } catch (Exception e) {
      Log.error(DefaultIdGenerator.class, e, "Could not calculate machine ID hash.");
      throw new RuntimeException(e);
    }
  }

  private static void insertAsBytes(long v, byte[] into) {
    into[0] = (byte) (v >>> 56);
    into[1] = (byte) (v >>> 48);
    into[2] = (byte) (v >>> 40);
    into[3] = (byte) (v >>> 32);
    into[4] = (byte) (v >>> 24);
    into[5] = (byte) (v >>> 16);
    into[6] = (byte) (v >>> 8);
    into[7] = (byte) (v);

  }

  private static void insertAsBytes(int v, int srcPos, byte[] into, int destPos, int length) {
    for (int i = srcPos; i < length; i++) {
      into[destPos + i] = (byte) (v >>> (24 - 8 * (srcPos + i)));
    }
  }

  @Nonnull
  @Override
  public String nextHex() {
    byte[] bytes;
    synchronized (autoInc) {
      bytes = nextBytes();
    }
    return Hex.encodeHexString(bytes);
  }

  @Override
  @Nonnull
  public BigInteger next() {
    byte[] bytes;
    synchronized (autoInc) {
      bytes = nextBytes();
    }
    return new BigInteger(bytes);
  }

  private byte[] nextBytes() {
    int nextAuto = autoInc.getAndIncrement();
    checkForOverflow(autoInc);
    byte[] bytes = new byte[16];
    long millis = System.currentTimeMillis();
    insertAsBytes(millis, bytes);
    //    @todo: Join these two arrays in class initialization so we only have one copy operation here.
    System.arraycopy(machineIdHash, 0, bytes, 8, 3);
    System.arraycopy(processIdHash, 0, bytes, 11, 2);
    // copy lower-order bytes from the int as the auto increment value
    insertAsBytes(nextAuto, 1, bytes, 13, 3);
    return bytes;
  }



}
 
